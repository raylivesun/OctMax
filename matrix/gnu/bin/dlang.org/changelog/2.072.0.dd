Ddoc

$(CHANGELOG_NAV_INJECT)

$(VERSION Oct 30, 2016, =================================================,

$(BUGSTITLE Language Changes,
    $(LI $(RELATIVE_LINK2 deprecated_commaexp, Using the result of a comma expression is deprecated.))

    $(LI $(RELATIVE_LINK2 deprecated_implicit_catch, Implicit catch statement are deprecated.))

    $(LI $(RELATIVE_LINK2 deprecated_implicit_cat, Implicit string concatenation is deprecated.))

    $(LI $(RELATIVE_LINK2 unrestricted_unions, Restrictions of postblits and destructors in union fields have been lifted.))

    $(LI $(RELATIVE_LINK2 align_by_ctfe, Align attribute can be used with CTFEable expression.))

    $(LI $(RELATIVE_LINK2 scope_value_parameters, `scope` is ignored for value parameters without indirections.))
)

$(BUGSTITLE Compiler Changes,
    $(LI $(RELATIVE_LINK2 iteration_closure, `opApply` now conservatively allocates a closure unless marked `scope`))
    $(LI $(RELATIVE_LINK2 native_tls_osx, Native TLS on OS X 64 bit.))
    $(LI $(RELATIVE_LINK2 deferred_alias, Analysis for aliases in imported modules is deferred.))
    $(LI $(RELATIVE_LINK2 __FILE_FULL_PATH__, Special keyword replaced by the source file's absolute file name.))
    $(LI $(RELATIVE_LINK2 dash_verrors_spec, Add `-verrors=spec` switch.))
)

$(BUGSTITLE Library Changes,
    $(LI $(RELATIVE_LINK2 TypeInfo.init-deprecated, `TypeInfo.init` has been deprecated.))
    $(LI $(RELATIVE_LINK2 drt-oncycle, New druntime switch `--DRT-oncycle`
    allows specifying what to do on cycle detection in modules.))
    $(LI Wrong
        $(LINK2 $(ROOT_DIR)spec/function.html#trusted-functions, `@trusted`)
        attributes have been
        removed from  $(MREF etc,c,curl) functions
        $(REF_ALTTEXT `curl_easy_escape`, curl_easy_escape, etc,c,curl),
        $(REF_ALTTEXT `curl_escape`, curl_escape, etc,c,curl),
        $(REF_ALTTEXT `curl_easy_unescape`, curl_easy_unescape, etc,c,curl), and
        $(REF_ALTTEXT `curl_unescape`, curl_unescape, etc,c,curl).)
    $(LI $(RELATIVE_LINK2 std-digest-murmurhash, Implementation of MurmurHash
        digest.))
    $(LI $(RELATIVE_LINK2 process, Process creation in `std.process` was sped up
        on Posix.))
    $(LI $(RELATIVE_LINK2 std-algorithm-iteration-cumulativeFold,
        `algorithm.iteration.cumulativeFold` was added.))
    $(LI $(RELATIVE_LINK2 padLeft-padRight, `std.range.padLeft` and
        `std.range.padRight` were added.))
    $(LI $(RELATIVE_LINK2 regex-multiple-patterns, `std.regex.regex` now
        supports matching multiple patterns in one go.))
    $(LI $(RELATIVE_LINK2 regex-with-matches, `std.regex.splitter` now
        supports keeping the pattern matches in the resulting range.))
    $(LI $(RELATIVE_LINK2 optimization, `findLocalMin` was added to `std.numeric`.))
    $(LI $(RELATIVE_LINK2 slice_ptr, `ptr` property and public constructor were
        added to `std.experimental.ndslice.slice.Slice`.))
    $(LI $(RELATIVE_LINK2 slice_toHash, `toHash` method was
        added to `std.experimental.ndslice.slice.Slice`.))
    $(LI $(RELATIVE_LINK2 slice_alloc, `slice`, `shape`, `ndarray`, and other
        utilities were added to `std.experimental.ndslice.slice`.))
    $(LI $(RELATIVE_LINK2 slice_as, `as` lazy tensor was added to
        `std.experimental.ndslice.slice`.))
    $(LI $(RELATIVE_LINK2 slice_iota, `iotaSlice` lazy tensor was added to
        `std.experimental.ndslice.selection`.))
    $(LI $(RELATIVE_LINK2 slice_index, `indexSlice` lazy tensor was added to
        `std.experimental.ndslice.selection`.))
    $(LI $(RELATIVE_LINK2 slice_repeat, `repeatSlice` lazy tensor was added to
        `std.experimental.ndslice.selection`.))
    $(LI $(RELATIVE_LINK2 slice_map, `mapSlice` lazy tensor was added to
        `std.experimental.ndslice.selection`.))
    $(LI $(RELATIVE_LINK2 slice_mio, partial support for Math Index Order
        was added to `std.experimental.ndslice.slice.Slice`.))
    $(LI $(RELATIVE_LINK2 mutation, `std.algorithm.mutation.swapAt` was
        exposed))
    $(LI $(RELATIVE_LINK2 iota-length-size_t, `std.range.iota's `.length`
        property is fixed to `size_t` instead of the type being iterated))
    $(LI $(REF isNumber, std,uni) and $(REF isPunctuation, std,uni) now use a separate,
    optimized path for ASCII inputs.)
    $(LI $(REF isAlphaNum, std,uni), which is analogous to $(REF isAlphaNum, std,ascii)
        was added.)
    $(LI $(REF regex, std,regex) now supports inline comments with (?#...) syntax.)
    $(LI std.regex had numerous optimization applied, compile-time $(REF ctRegex, std,regex)
    should now be generally faster then the run-time version.)
    $(LI $(REF moveAt, std,range,primitives) accepts only `size_t` for its index
    arguments.)
    $(LI $(REF isStrictlyMonotonic, std,algorithm,sorting) which doesn't allow
    equal values was added.)
    $(LI $(REF readLink, std,file) and $(REF symlink, std,file) have been
        rangified.)
    $(LI All overloads of `std.conv.toImpl` has been made private. Please use
        $(REF to, std,conv) instead.)
    $(LI $(RELATIVE_LINK2 min-max-element,
    `std.algorithm.searching.{min,max}Element` for ranges have been added.))
    $(LI $(REF Ternary, std,typecons) was added to represent three valued
    logic.)
    $(LI $(RELATIVE_LINK2 quantize, Added `std.math.quantize`, for rounding to
        the nearest multiple of some number.))
    $(LI $(RELATIVE_LINK2 traits, Three new traits were added to `std.traits`.))
    $(LI $(RELATIVE_LINK2 generate, `std.range.generate` fixed to be a proper
        range.))
    $(LI $(MREF std,numeric) no longer uses `enforce` for verifying
    contract preconditions.)
    $(LI $(RELATIVE_LINK2 headconst, `Final` was added to
    `std.experimental.typecons`))
    $(LI $(RELATIVE_LINK2 inner-class, `std.traits.isInnerClass` was added to
    identify nested classes with an accessible `outer` pointer))
    $(LI $(RELATIVE_LINK2 emplace-inner-class, `std.conv.emplace` no longer allows
    to emplace classes directly nested inside other classes without specifying a
    suitable `outer` pointer))
    $(LI $(RELATIVE_LINK2 gc-runtimeswitch-added, A switch for selecting
    the GC implementation at runtime was added.))
    $(LI $(RELATIVE_LINK2 manualgc-added, A GC implementation allowing manual
    memory management was added.))
)

$(BR)$(BIG $(RELATIVE_LINK2 bugfix-list, List of all bug fixes and enhancements in D $(VER).))

$(HR)

$(BUGSTITLE Language Changes,
    $(LI $(LNAME2 deprecated_commaexp, Using the result of a comma expression is deprecated.)

    $(P Comma expressions have proven to be a frequent source of confusion, and bugs -
    see $(HTTPS issues.dlang.org/show_bug.cgi?id=2659#c2, here) for examples.)

    $(P Using the result of a comma expression will now trigger a deprecation message.)

    $(P Example:)

        ---
        void main () {
          // OK, result of increment not directly used
          for (int i, j; i != 3; i++, j++) {...}

          auto r1 = getRange!int, r2 = getRange!int;
          // OK
          for (; !r1.empty && !r2.empty; r1.popFront, r2.popFront) {...}
          // Deprecated - the loop condition is always used
          for (; !r1.empty, !r2.empty; r1.popFront, r2.popFront) {...}

          MyContainerClass mc;
          // OK - expression statement, result not used
          if (!mc)
            (mc = new MyContainerClass), mc.append(new Entry);

          int i;
          // Deprecated
          mc = (i++, new MyContainerClass);
        }
        ---
    )

    $(LI $(LNAME2 deprecated_implicit_catch, Implicit catch statement are deprecated.)

    $(P Implicit catch statement are catch statement without type specified.
        They default to catching `Throwable`, which is something that should always be explicit.)

    $(P Example:)

        ---
        int[] arr = new int[](10);
        // This will throw a RangeError
        try { arr[42]++; }
        catch { writeln("An error was caught and ignored"); }
        // The previous line is equivalent to:
        // catch (Throwable) { writeln("An error was caught and ignored"); }
        ---
    )

    $(LI $(LNAME2 deprecated_implicit_cat, Implicit string concatenation is deprecated.)

    $(P Implicit concatenation of string literal is a very early feature that is now supplanted
        by the concatenation operator ('~'), the later being more explicit.)

    $(P It could result in hard to spot bug, where one missed a comma in an array expression:)

        ---
        void foo ()
        {
          string[] arr = [ "Hello", "buggy" "World" ];
          assert(arr.length == 3); // Fail, the length of the array is 2 and the content is [ "Hello", "buggyWorld" ]
        }
        ---
    )

    $(LI $(LNAME2 unrestricted_unions, Restrictions of postblits and destructors in union fields have been lifted.)

    $(P It is now allowed to have fields with postblits (`this(this)`),
         destructors (`~this()`), or invariants (`invariant()`) in unions.
         Actually destructing or blitting the correct field is the duty of the
         programmer.)

    $(P Example:)

        ---
        struct S { this(this) {} ~this() {} }
        union U
        {
            int var;
            S s;
        }

        unittest
        {
            U u; // won't call s.~this when u goes out of scope
            u = U(); // only copies the memory, use fieldwise assignment instead
            u.s = S(); // works like normal struct assignment
            destroy(u.s); // destroy currently used field
        }
        ---
    )

    $(LI $(LNAME2 align_by_ctfe, Align attribute can be used with CTFEable expression.)

    $(P Example:)

        ---
        version (D_LP64)
            enum n = 8;
        else
            enum n = 4;
        align (n) struct Data
        {
        align (n == 8 ? 2 : 1):
            ubyte[3] buffer;
            int flags;
        }

        version (D_LP64)
            static assert(Data.flags.offsetof == 4);
        else
            static assert(Data.flags.offsetof == 3);
        ---
    )

    $(LI $(LNAME2 scope_value_parameters, `scope` is now ignored for value parameters without indirections.)

    $(P The `scope` storage class is now ignored for copied value parameters that don't have any indirections.)

    $(P Example:)

        ---
        import std.traits;
        void valueParam(scope int param);
        static assert(ParameterStorageClassTuple!valueParam[0] == ParameterStorageClass.none);
        void scopeParam(scope int* param);
        static assert(ParameterStorageClassTuple!scopeParam[0] == ParameterStorageClass.scope_);
        ---
    )
)

$(BUGSTITLE Compiler Changes,
    $(LI $(LNAME2 native_tls_osx, Native TLS on OS X 64 bit.)

        $(P
            The compiler has been updated to use native thread local storage
            (TLS) on OS X when compiling for 64 bit. This means that it's
            possible to to link with C/C++ TLS variables. This change is an ABI
            breaking change and requires recompiling libraries.
        )

        $(P
            The minimum required version of running the compiler and any
            produced binary is now Mac OS X Lion (10.7).
        )

        $(P
            Xcode 7.3 has a bug causing linker errors for some TLS variables.
            Xcode 7.3.1 fixes this bug. Any version older than 7.3 works as well.
        )
    )

    $(LI $(LNAME2 deferred_alias, Analysis for aliases in imported modules is deferred.)

    $(P Example:)

        ---
        module lib;
        template ExpensiveApiImpl(int ver)
        {
            ...
            void func() {}
            pragma(msg, "instantiated ExpensiveApiImpl ", ver);
        }
        alias api1 = ExpensiveApiImpl!(1);
        alias api2 = ExpensiveApiImpl!(2);
        ---

        ---
        import lib;
        void main()
        {
            // OK, prints "instantiated ExpensiveApiImpl 1"
            api1.func();

            // Don't print "instantiated ExpensiveApiImpl 2", because
            // the alias name 'api2' is not used.
        }
        ---
    )

    $(LI $(LNAME2 __FILE_FULL_PATH__, Special keyword replaced by the source file's absolute file name.)
        $(P
            The __FILE_FULL_PATH__ special keyword is replaced by the absolute path
            of the current source file by the compiler.
        )
        $(P Example:)
        ---
        import std.stdio;
        import std.path;
        import std.file;
        void main()
        {
            writeln("The main source file lives here: ", __FILE_FULL_PATH__);
            writeln("The contents are:");
            foreach(line; File(__FILE_FULL_PATH__, "r").byLine) {
                writeln(line);
            }
            writeln();
            writeln("Other files in the same directory are:");
            foreach(entry; dirEntries(__FILE_FULL_PATH__.dirName, SpanMode.shallow)) {
                writefln("  - %s", entry.name);
            }
        }
        ---
    )

    $(LI $(LNAME2 dash_verrors_spec, Add `-verrors=spec` switch.)
        $(P Shows errors from speculative compiles such as:)
        ---
        void foo(int i)
        {
            int p;
            bool b = __traits(compiles, { p = &i; });
        }
        ---
        $(P that are normally not shown:)
        ---
        (spec:1) test.d(13): Error: cannot implicitly convert expression (& i) of type int* to int
        ---
        $(P The number after `spec:` is the nesting of the speculative compiles.)
    )
)

$(BUGSTITLE Library Changes,

    $(LI $(LNAME2 TypeInfo.init-deprecated, `TypeInfo.init` has been
        deprecated.)

        $(P This is a step towards removal of `TypeInfo.init`, which is necessary
            to resolve a name clash with the type property $(GLINK2 property, init).
        )

        $(P Use $(REF1 TypeInfo.initializer, object) instead.)
    )

    $(LI $(LNAME2 drt-oncycle, New druntime switch `--DRT-oncycle` allows
        specifying what to do on cycle detection in modules.)
        $(P When module cycles are detected, the default behavior is to print
            the cycle, and abort execution. However, in many cases, the cycles
            are not harmful. With the new `--DRT-oncycle` switch, you can effect
            a different behavior when cycles are detected:)
        $(DL
            $(DT `--DRT-oncycle=abort`)
            $(DD This is the default behavior, and will abort, printing the cycle to `stderr` when the first cycle is detected)
            $(DT `--DRT-oncycle=print`)
            $(DD Print all cycles that are detected to `stderr`, but do not halt execution. Order of initialization is arbitrarily chosen based on the order the modules are in the binary)
            $(DT `--DRT-oncycle=ignore`)
            $(DD Do not print anything, and do not halt execution. Order of initialization is arbitrarily chosen based on the order the modules are in the binary)
        )
        ($P As there were improvements of the cycle detection algorithm implemented within the scope of this release,
            previously undetected (even harmless) module dependency cycles may start to abort program execution
            or program may malfunction due to changed call order of module static construction/destruction.
            In order to preserve the program behaviour without the need to specify `--DRT-oncycle` command line argument,
            it is possible to instruct the linker by declaring the following array in the source code:)

            ---
            extern(C) __gshared string[] rt_options = [ "oncycle=ignore" ];
            ---

        ($P For more information, please consult the D language specification, section Overriding Cycle Detection Abort in chapter 4
            and chapter 28.7 Configuring the Garbage Collector.)
    )

    $(LI $(LNAME2 std-digest-murmurhash, Implementation of `std.digest.murmurhash`).
        $(P $(MREF std,digest,murmurhash) has been added. MurmurHash is a
          non-cryptographic hash function suitable for general hash-based lookup. It
          is optimized for x86 architectures.
        )
    ------
    // Computing the 32-bits hash value of an int array using the convenient digest template.
    import std.digest.murmurhash;

    ubyte[4] hashed = digest!MurmurHash3_32_opt32([1, 2, 3, 4]);
    ------
    )

    $(LI $(LNAME2 process, Process creation in `std.process` was sped up on Posix.)
        $(P Previously, Posix systems would attempt to close every file descriptor
            from 3 to the maximum file descriptor number if `inheritFDs` was not
            specified with `spawnProcess`, `pipeProcess`, etc.
            $(MREF std,process) now uses `poll()` to determine which
            descriptors need closing.
        )
    )

    $(LI $(LNAME2 std-algorithm-iteration-cumulativeFold,
        `algorithm.iteration.cumulativeFold` was added.)

        $(P $(REF cumulativeFold, std,algorithm,iteration) returns the successive
            reduced values of an input range.)
    ------
    assert([1, 2, 3, 4, 5].cumulativeFold!((a, b) => a + b).array == [1, 3, 6, 10, 15]);
    assert([1, 2, 3].cumulativeFold!((a, b) => a + b)(100).array == [101, 103, 106]);
    ------
    )

    $(LI $(LNAME2 padLeft-padRight, `std.range.padLeft` and `std.range.padRight`
            were added.)
        $(P $(REF padLeft, std,range) and $(REF padRight, std,range) are functions for
            padding ranges to a specified length using the given element.
        )

    -------
    import std.range;
    import std.algorithm.comparison;

    assert([1, 2, 3, 4, 5].padLeft(0, 7).equal([0, 0, 1, 2, 3, 4, 5]));

    assert("Hello World!".padRight('!', 15).equal("Hello World!!!!"));
    -------
    )

    $(LI $(LNAME2 regex-multiple-patterns, `std.regex.regex` now supports matching multiple patterns in one go.)
    -------
    import std.regex;
    // multi-pattern regex
    auto multi = regex([`\d+,\d+`,`(a-z]+):(\d+)`]);
    auto m = "abc:43 12,34".matchAll(multi);
    assert(m.front.whichPattern == 2);
    assert(m.front[1] == "abc");
    assert(m.front[2] == "43");
    m.popFront();
    assert(m.front.whichPattern == 1);
    assert(m.front[1] == "12");
    -------
    )

    $(LI $(LNAME2 regex-with-matches, `std.regex.splitter` now supports keeping the
    pattern matches in the resulting range.)
    -------
    import std.regex;
    import std.algorithm.comparison : equal;

    auto pattern = regex(`([\.,])`);
    assert("2003.04.05"
        .splitter!(No.keepSeparators)(pattern)
        .equal(["2003", "04", "05"]));
    assert("2003.04.05"
        .splitter!(Yes.keepSeparators)(pattern)
        .equal(["2003", ".", "04", ".", "05"]));
    -------
    )

    $(LI $(LNAME2 optimization, `findLocalMin` was added to `std.numeric`.)
        $(P $(REF findLocalMin, std,numeric) finds a real minimum of a real function `f(x)` via bracketing.)
    -------
    import std.numeric, std.math;

    auto ret = findLocalMin((double x) => (x-4)^^2, -1e7, 1e7);

    assert(ret.x.approxEqual(4.0));
    assert(ret.y.approxEqual(0.0));
    -------
    )

    $(LI $(LNAME2 slice_ptr, `ptr` property and public constructor were added to
        `std.experimental.ndslice.slice.Slice`.)
        $(P `ptr` property allows to access `Slice`'s underlaying pointer or range.
            Please refer to $(D std.experimental.ndslice.slice.Slice)'s
            internal binary epresentation before using the property.
            `ptr` property is used in $(LINK2 https://github.com/libmir/mir, Mir)
            for $(LINK2 http://docs.mir.dlang.io/latest/mir_sparse.html, sparse tensors).
            `ndslice` developer mirror in Mir will be removed as
            soon as LDC (LLVM D compiler) supports D version 2.072.
        )
        $(P Public constructor for `Slice` was added to support
            $(D std.experimental.ndslice) integration
            with other languages and libraries such as Julia language and NumPy library.
        )
    )

    $(LI $(LNAME2 slice_toHash, $(P $(D std.experimental.ndslice.slice.Slice.toHash) method was added.))
    ---
    import std.experimental.ndslice;

    // hash is the same for allocated data and generated data
    auto a = iotaSlice(3, 7);
    auto b = iotaSlice(3, 7).slice;

    assert(a.toHash == b.toHash);
    ---
    )

    $(LI $(LNAME2 slice_alloc, `slice`, `shape`, `ndarray`, and other utilities
        were added to `std.experimental.ndslice.slice`.)
        $(P These utility functions have been added to
            $(D std.experimental.ndslice):)
        $(UL
            $(LI $(D std.experimental.ndslice.slice.makeNdarray),)
            $(LI $(D std.experimental.ndslice.slice.makeSlice),)
            $(LI $(D std.experimental.ndslice.slice.makeUninitializedSlice),)
            $(LI $(D std.experimental.ndslice.slice.ndarray),)
            $(LI $(D std.experimental.ndslice.slice.shape),)
            $(LI $(D std.experimental.ndslice.slice.slice),)
            $(LI $(D std.experimental.ndslice.slice.uninitializedSlice).)
        )
        $(P Example: Transposing common 2D array using `ndslice`)
    -----
    import std.experimental.ndslice;

    auto ar = [[0, 1, 2], [3, 4, 5]];

    auto sh = ar.shape;         // [2, 3] type of size_t[2]
    auto sl = slice!int(sh);    // allocates slice with corresponding shape
    sl[] = ar;                  // fills sl with values from ar
    ar = sl.transposed.ndarray; // allocates common 2D array

    assert(ar == [[0, 3], [1, 4], [2, 5]]);
    -----
    )

    $(LI $(LNAME2 slice_as, $(P $(D std.experimental.ndslice.slice.as)
        lazy tensor was added.))
    ---
    import std.experimental.ndslice;

    auto matrix = slice!double([2, 2], 0);
    auto stringMatrixView = matrix.as!string;
    assert(stringMatrixView ==
            [["0", "0"],
             ["0", "0"]]);

    matrix.diagonal[] = 1;
    assert(stringMatrixView ==
            [["1", "0"],
             ["0", "1"]]);
    ---
    )

    $(LI $(LNAME2 slice_iota, `iotaSlice` lazy tensor was added to `std.experimental.ndslice.selection`.)
        $(P $(D std.experimental.ndslice.selection.iotaSlice) is the fastest possible `Slice`.)
    ---
    import std.experimental.ndslice;

    auto sl = iotaSlice([2, 3], 10);

    assert(sl.transposed == [[10, 13],
                             [11, 14],
                             [12, 15]]);
    ---
    )

    $(LI $(LNAME2 slice_index, $(P $(D std.experimental.ndslice.selection.indexSlice)
        lazy tensor was added.))
    ---
    import std.experimental.ndslice;

    auto slice = indexSlice(2, 3);

    assert(slice == [[[0, 0], [0, 1], [0, 2]],
                     [[1, 0], [1, 1], [1, 2]]]);
    ---
    )

    $(LI $(LNAME2 slice_repeat, $(P $(D std.experimental.ndslice.selection.repeatSlice)
        lazy tensor was added.))
    ---
    import std.experimental.ndslice;

    auto sl = iotaSlice(3).repeatSlice(4);
    assert(sl == [[0, 1, 2],
                  [0, 1, 2],
                  [0, 1, 2],
                  [0, 1, 2]]);

    auto m = 4.repeatSlice(2, 3);
    assert(m == [[4, 4, 4],
                 [4, 4, 4]]);
    ---
    )

    $(LI $(LNAME2 slice_map, $(P $(D std.experimental.ndslice.selection.mapSlice)
        lazy tensor was added.))
    ---
    import std.experimental.ndslice;

    auto s = iotaSlice(2, 3).mapSlice!(a => a * a);
    assert(s == [[ 0,  1,  4],
                 [ 9, 16, 25]]);
    ---
    )

    $(LI $(LNAME2 slice_mio, partial support for Math Index Order was added to `std.experimental.ndslice.slice.Slice`.)
    ---
    import std.experimental.ndslice;

    auto sl = iotaSlice(3, 4);

    assert(sl[2, 3] == 11); // D & C index order
    assert(sl(3, 2) == 11); // Math & Fortran index order
    ---
    )

    $(LI $(LNAME2 mutation, `std.algorithm.mutation.swapAt` was exposed)
        $(P $(REF swapAt, std,algorithm,mutation) allows to swap elements
            of a RandomAccessRange by their indices.
        )
    )

    $(LI $(LNAME2 iota-length-size_t, `std.range.iota`'s `.length` property is fixed
            to `size_t` instead of the type being iterated)
        $(P $(REF iota, std,range)'s `.length` property is now always returned as
            `size_t`.  This means if you are on a 32-bit CPU and you are using
            iota to iterate 64-bit types, the length will be truncated to `size_t`.
            In non-release mode, you will get an exception if the length exceeds
            `size_t.max` in your call to `iota`.
        )
    )

    $(LI $(LNAME2 min-max-element, `std.algorithm.searching.{min,max}Element`
        have been added.)
        $(P $(REF minElement, std,algorithm,searching) and $(REF maxElement, std,algorithm,searching)
        are functions to search for the minimum and maximum
        element in a range. They support a custom `map` accessor.
        )

    -------
    import std.algorithm.searching;
    import std.range;
    import std.typecons;
    assert([3, 1, 4].minElement == 1);
    assert([4, 7, 5].enumerate.maxElement!`a.value` == tuple(1, 7));
    -------
    )

    $(LI $(LNAME2 quantize, Added `std.math.quantize`.)
        $(P $(REF quantize, std,math) rounds to the nearest multiple of some number.
            Features:)
        $(UL
            $(LI The rounding method can be specified using the `rfunc` parameter. By
                default, the current rounding mode will be used, which is typically
                "banker's rounding".)
            $(LI Overloads are included for the common case of rounding to the $(I Nth)
                digit place in some base.)
            $(LI If known at compile time, the base and exponent (digit place) can be
                supplied as template parameters for better performance.)
        )
    ---
    import std.math;

    assert(12345.6789L.quantize(20.0L) == 12340.0L);
    assert(12345.6789L.quantize!(10, -2) == 12345.68L);
    assert(12345.6789L.quantize!(10, floor)(-2) == 12345.67L);
    ---
    )

    $(LI $(LNAME2 traits, Three new traits were added to `std.traits`.)
        $(P $(REF isType, std,traits), $(REF isFunction, std,traits), and
        $(REF isFinal, std,traits) were added to `std.traits`.
        )

    -------
    import std.traits;

    static assert(isType!int);

    struct S {}
    class C {}
    interface I {}

    static assert(isType!S);
    static assert(isType!C);
    static assert(isType!I);
    -------

    -------
    import std.traits;

    void func(){}
    struct S
    {
        @property int prop(){ return 0; }
    }

    static assert(isFunction!func);
    static assert(isFunction!(S.prop));

    // is a delegate type, not function type
    static assert(!isFunction!(typeof(&S.prop)));
    -------

    -------
    import std.traits;

    class C
    {
        void nf() {}
        final void ff() {}
    }
    final class FC {}

    static assert(!isFinal!(C));
    static assert( isFinal!(FC));
    static assert(!isFinal!(C.nf));
    static assert( isFinal!(C.ff));
    -------
    )

    $(LI $(LNAME2 generate, `std.range.generate` fixed to be a proper range.)
        $(P $(REF generate, std, range) was set up to return a different value on each
        call to `front`. In addition, `popFront` did nothing. This means that
        manipulation functions like $(REF drop, std, range) did nothing. The new
        version uses a one-element cache to meet the expectations of the range
        definition. It preserves the ref-ness of the generator as well.
        )
    )

    $(LI $(LNAME2 headconst, `Final` was added to `std.experimental.typecons`.)
        $(P $(REF Final, std, experimental, typecons) can't be mutated directly.
        However references are typed with their original mutability.  This is
        equivalent to `final` in Java or `readonly` in C#.
        )
    -------
    auto a = makeFinal([1, 2, 3]);
    assert(a[0] == 1);

    // a = [2, 3]; // Reassignment is illegal,
    a[0] = 42; // Elements or fields are still mutable.

    assert(a[0] == 42);
    -------
    )

    $(LI $(LNAME2 inner-class, `std.traits.isInnerClass` was added to identify
        nested classes with an accessible `outer` pointer)
        $(P Classes, that are nested inside other classes (and not inside functions)
        and that don't define any `outer` symbol, have an `outer` field which allows
        to get and even set the instance of the outer class they are nested in.
        $(REF isInnerClass, std, traits) allows to identify them. The types satisfying
        `isInnerClass` are a subset of the ones satisfying `isNested`, as the latter
        includes classes and structures nested inside functions or that redefine `outer`.
        )
    -------
    class Outer
    {
        class Inner1 { }
        class Inner2
        {
            int outer; // redefines outer, so the Outer instance is not accessible
        }
        static class Inner3 {}  // static, thus not nested
    }
    static assert(isInnerClass!(Outer.Inner1));
    static assert(!isInnerClass!(Outer.Inner2));
    static assert(!isInnerClass!(Outer.Inner3));
    -------
    )

    $(LI $(LNAME2 emplace-inner-class, `std.conv.emplace` no longer allows to emplace
        classes nested directly inside other classes without specifying a suitable `outer`
        pointer)
        $(P If a class is nested within another class (there's a new trait
        $(REF isInnerClass, std, traits) to check for this condition), `emplace` requires
        now the outer class instance as additional mandatory parameter. Before this
        change, emplacing did not require this parameter and access to variables of the
        outer class resulted in segmentation faults.
        )
    -------
    class Outer
    {
        int x;
        class Inner
        {
            auto getX() { return x; }
        }
    }
    Outer outer = new Outer();

    // auto inner = buf.emplace!(Outer.Inner)();   // this is no longer allowed
    auto inner = buf.emplace!(Outer.Inner)(outer); // use this instead

    auto x = inner.getX();  // this used to cause a segmentation fault;
                            // now it works as expected
    -------
    )

    $(LI $(LNAME2 gc-runtimeswitch-added, A runtime switch for selecting
         the GC implementation was added.)

        $(P This allows to select a GC at program startup.)
        -------
        ./my_d_exe --DRT-gcopt=gc:conservative # use conservative GC (default)
        ./my_d_exe --DRT-gcopt=help # list available GC options
        -------
        $(P See $(LINK2 $(ROOT_DIR)spec/garbage.html#gc_config, gc_config) for more information about gcopt.)
        $(P In a future release it should be possible to extend the list
            of GCs by linking with an alternative one.
        )
    )

    $(LI $(LNAME2 manualgc-added, A manual GC was added.)

        $(P Use the `--DRT-gc=gc:manual` option to select the manual GC.)

        $(P This GC is a thin wrapper around malloc and free and does not collect
            any garbage. It only releases memory explicity freed using $(REF_SHORT GC.free, core,memory).
            Builtin language constructs such as arrays or delegates that might
            allocate GC memory can leak.  It supersedes the gcstub implementation.
        )

        $(P The manual GC is useful for applications that deterministically control memory.
            Use dmd's `-vgc` switch to keep track of hidden allocations that might leak.
        )
        $(P It can also be helpful to find memory corruptions with tools like valgrind.)
    )
)
)


$(BR)$(BIG $(LNAME2 bugfix-list, List of all bug fixes and enhancements in D $(VER):))

$(BUGSTITLE DMD Compiler regressions,

$(P
$(LI $(BUGZILLA 15726): [REG2.068.0] forward reference error for circular classes, RefCounted)
$(LI $(BUGZILLA 15861): [REG 2.069] Wrong double-to-string conversion with -O)
$(LI $(BUGZILLA 15925): -transition=[check]imports ignores import declaration from mixin templates)
$(LI $(BUGZILLA 15992): [REG2.072a] ICE with field variable of instantiated struct)
$(LI $(BUGZILLA 16080): [REG2.071.0] Internal error: backend\cgobj.c 3406 when building static library)
$(LI $(BUGZILLA 16115): [REG2.067] Wrong code with comma operator)
$(LI $(BUGZILLA 16233): [REG2.069] ICE on wrong code)
$(LI $(BUGZILLA 16254): [REG 2.072-devel] wrong switch skips initialization error with mixed in case labels)
$(LI $(BUGZILLA 16292): [REG2.069] bogus Error: goto skips declaration of variable)
$(LI $(BUGZILLA 16536): DMD master does not build on OS X 10.11.6/Xcode 7.3.1)
$(LI $(BUGZILLA 16570): [REG 2.072.0-b1] Enum member with interpreted initializer has type of initializer not enum)
)
)
$(BUGSTITLE DMD Compiler bugs,

$(P
$(LI $(BUGZILLA 1357): Cannot use FFFF and FFFE in Unicode escape sequences.)
$(LI $(BUGZILLA 5305): Cannot take pointer to intrinsic function)
$(LI $(BUGZILLA 10225): core.simd wrong codegen for XMM.STOUPS with __simd_sto)
$(LI $(BUGZILLA 10591): Error: only one main allowed doesn't show location of conflicting main symbols)
$(LI $(BUGZILLA 11047): UDA + getAttributes bypass purity/safety check)
$(LI $(BUGZILLA 11169): __traits$(LPAREN)isAbstractClass$(RPAREN) prematurely sets a class to be abstract)
$(LI $(BUGZILLA 11585): ICE$(LPAREN)cgcod.c$(RPAREN) with SIMD and -O)
$(LI $(BUGZILLA 12357): Untyped string variable fails silently. No compiler warning given.)
$(LI $(BUGZILLA 12527): Cannot make @system function/delegate alias in a @safe section)
$(LI $(BUGZILLA 12537): Templatizing opEquals results in infinite recursion in the compiler)
$(LI $(BUGZILLA 12558): try/catch allows implicit catching of Errors without specifying any Exception type)
$(LI $(BUGZILLA 12822): Delegate .ptr assignment considered @safe)
$(LI $(BUGZILLA 12939): More uniform error messages for not nothrow and not @safe functions)
$(LI $(BUGZILLA 13116): Should not be able to return ref to 'this')
$(LI $(BUGZILLA 13147): Wrong codegen for thisptr in naked extern $(LPAREN)C++$(RPAREN) methods)
$(LI $(BUGZILLA 13536): Union of delegates breaks @safety)
$(LI $(BUGZILLA 13537): Unions may break immutability)
$(LI $(BUGZILLA 13674): ICE$(LPAREN)el.c$(RPAREN) with simd multiplication of short8)
$(LI $(BUGZILLA 13698): ICE$(LPAREN)e2ir.c$(RPAREN) on on simd call)
$(LI $(BUGZILLA 13867): Overriding a method from an extern$(LPAREN)C++$(RPAREN) interface requires extern$(LPAREN)C++$(RPAREN) on the method definition)
$(LI $(BUGZILLA 13975): ICE: dmd crash if -gc and enum member is immutable int)
$(LI $(BUGZILLA 14162): Erratic inference of @safe for lambdas)
$(LI $(BUGZILLA 14450): Incorrect overloading of immutable constructor for template struct)
$(LI $(BUGZILLA 14496): void initialization of member with indirections must not be @safe)
$(LI $(BUGZILLA 14504): Regex Optimizer doesn't merge equivalent threads.)
$(LI $(BUGZILLA 14532): switch block allows creating uninitialized variables)
$(LI $(BUGZILLA 15116): Unreasonable rejection of tuple field access via named mixin)
$(LI $(BUGZILLA 15117): Unreasonable circular reference error via named mixin)
$(LI $(BUGZILLA 15144): Bad operand size in asm { movdqa ... } produces bogus ubyte16 initializer error elsewhere.)
$(LI $(BUGZILLA 15191): DIP25: Taking address of ref return is not type checked soundly)
$(LI $(BUGZILLA 15192): DIP25: Nested ref returns are type checked unsoundly)
$(LI $(BUGZILLA 15193): DIP25 $(LPAREN)implementation$(RPAREN): Lifetimes of temporaries tracked incorrectly)
$(LI $(BUGZILLA 15258): Anonymous const union members don't allow for initialization)
$(LI $(BUGZILLA 15306): Delegates with shared context can have unshared aliasing)
$(LI $(BUGZILLA 15326): False positive for dangling else warning)
$(LI $(BUGZILLA 15333): Assertion failed: $(LPAREN)!fd->vthis->csym$(RPAREN), function FuncDeclaration_toObjFile, file glue.c, line 1034.)
$(LI $(BUGZILLA 15372): DMD emits wrong mangling for extern$(LPAREN)C++$(RPAREN) free function templates)
$(LI $(BUGZILLA 15399): unaligned pointers are not @safe)
$(LI $(BUGZILLA 15513): Memory Corruption with thread local objects)
$(LI $(BUGZILLA 15573): -O -inline causes wrong code with idiv instruction)
$(LI $(BUGZILLA 15607): [ICE] CTFE internal error: bad compare on accessing default-initialized static immutable array of array)
$(LI $(BUGZILLA 15672): Casting from void[] to T[] is erroneously considered @safe)
$(LI $(BUGZILLA 15680): TypeInfo broken for typeof$(LPAREN)null$(RPAREN))
$(LI $(BUGZILLA 15703): @safe code should not allow certain types of array casts)
$(LI $(BUGZILLA 15704): @safe code should not allow copying to/from void[])
$(LI $(BUGZILLA 15757): D main is a nested function and cannot be accessed)
$(LI $(BUGZILLA 15760): Segfault when compiling when using __gshared and selective import.)
$(LI $(BUGZILLA 15762): Array casts involving const enums can be made @safe)
$(LI $(BUGZILLA 15799): Misleading error message against the contract followed by semicolon in interface)
$(LI $(BUGZILLA 15802): $(LPAREN)SIGSEGV$(RPAREN) CppMangleVisitor::source_name)
$(LI $(BUGZILLA 15816): ICE void ddmd.dclass.__assert$(LPAREN)int$(RPAREN) with error: anonymous classes not allowed)
$(LI $(BUGZILLA 15835): Segfault with typeid call from lazy argument)
$(LI $(BUGZILLA 15855): "a[{for" causes dmd to segfault)
$(LI $(BUGZILLA 15913): cannot initialize immutable fixed size array without similar const-code)
$(LI $(BUGZILLA 15922): DMD segfault in functionParameters$(LPAREN)$(RPAREN))
$(LI $(BUGZILLA 15934): Non-virtual super class member function call ignores 'this' type qualifier)
$(LI $(BUGZILLA 15957): Disabled postblit + template mixin break opAssign with confusing error message)
$(LI $(BUGZILLA 15974): Spurious error: argument to mixin must be a string, not $(LPAREN)expression$(LPAREN)$(RPAREN)$(RPAREN) of type string)
$(LI $(BUGZILLA 15999): Inline assembly incorrect sign extension instead of error)
$(LI $(BUGZILLA 16035): Compiler crashes with inout, templates, and recursion)
$(LI $(BUGZILLA 16094): error: overlapping slice assignment $(LPAREN)CTFE$(RPAREN))
$(LI $(BUGZILLA 16095): a delegate can mutate immutable data and break shared / non-shared enforcements)
$(LI $(BUGZILLA 16096): Linking to static library: can't parse __DATA/__objc_imageinfo)
$(LI $(BUGZILLA 16142): Adding a dtor / postblit $(LPAREN)even disabled$(RPAREN) forces opAssign)
$(LI $(BUGZILLA 16193): opApply$(LPAREN)$(RPAREN) doesn't heap allocate closure)
$(LI $(BUGZILLA 16195): delete should be @system)
$(LI $(BUGZILLA 16226): -dip25 doesn't work if the return type is not explicit)
$(LI $(BUGZILLA 16228): Insufficient diagnostics for wrong application of DIP25)
$(LI $(BUGZILLA 16229): [Win64] Crash when generating huge symbols)
$(LI $(BUGZILLA 16340): case where version$(LPAREN)unittest$(RPAREN) results in an invalid warning about a dangling else)
$(LI $(BUGZILLA 16365): cannot allow calling function pointer from delegate in @safe code)
$(LI $(BUGZILLA 16439): Non-typesafe variadic functions can never be @safe)
$(LI $(BUGZILLA 16466): Alignment of reals inside structs on 32 bit OSX should be 16, not 8)
$(LI $(BUGZILLA 16525): C++ member variables have no mangling)
$(LI $(BUGZILLA 16530): -O -cov interaction leads to wrong codegen)
$(LI $(BUGZILLA 16534): RefRange should define opDollar if it defines length)
)
)
$(BUGSTITLE DMD Compiler enhancements,

$(P
$(LI $(BUGZILLA 2659): Remove the comma operator)
$(LI $(BUGZILLA 3657): No lexical scope for local variables in debug info)
$(LI $(BUGZILLA 3827): Warn against and then deprecate implicit concatenation of adjacent string literals)
$(LI $(BUGZILLA 9766): align$(LPAREN)n$(RPAREN) with n compile-time constant)
$(LI $(BUGZILLA 11886): "cannot access frame" error on lambda in lambda)
$(LI $(BUGZILLA 13242): imported aliases should be analyzed lazily)
$(LI $(BUGZILLA 14411): switch statement: docs/behavior differ)
$(LI $(BUGZILLA 15323): Module.members and .deferred3 should use data structure with fast lookup)
$(LI $(BUGZILLA 16077): [CodeView] no language information in MS-COFF debug information)
$(LI $(BUGZILLA 16394): TypeInfo.init$(LPAREN)$(RPAREN) for static arrays returns single element instead of whole array)
$(LI $(BUGZILLA 16409): Add support for assign-style switches)
)
)
$(BUGSTITLE Phobos regressions,

$(P
$(LI $(BUGZILLA 15457): Symbol Undefined __lseeki64)
$(LI $(BUGZILLA 15918): [2.070] Results from findSplit can no longer be assigned to each other)
$(LI $(BUGZILLA 16179): [REG2.072] git HEAD: multiSort no longer callable with delegate with context)
$(LI $(BUGZILLA 16291): phobosinit never gets called $(LPAREN)EncodingScheme.create fails$(RPAREN))
$(LI $(BUGZILLA 16544): Add File.reopen)
$(LI $(BUGZILLA 16580): [REG 2.072.0-b1] spawnShell segfaults on macOS)
$(LI $(BUGZILLA 16587): split$(LPAREN)"", "x"$(RPAREN) should be [])
)
)
$(BUGSTITLE Phobos bugs,

$(P
$(LI $(BUGZILLA 4509): XML parser in std.xml throws TagException if the attr value is put in apostrophes.)
$(LI $(BUGZILLA 7972): std.file.read allocate a buffer the size of the file even when given a upper limit)
$(LI $(BUGZILLA 7989): isInputRange and isForwardRange declare unused variables)
$(LI $(BUGZILLA 11791): std.file.write failed to write huge files)
$(LI $(BUGZILLA 12368): std.file.write conflicts with std.stdio.write)
$(LI $(BUGZILLA 12897): std.json.toJSON doesn't translate unicode chars$(LPAREN)>=0x80$(RPAREN) to "\uXXXX")
$(LI $(BUGZILLA 13572): etc.c.zlib must be nothrow)
$(LI $(BUGZILLA 14136): std.uni.utfMatcher breaks @safety)
$(LI $(BUGZILLA 14137): std.socket.getAddressInfo breaks @safety)
$(LI $(BUGZILLA 14485): .front of empty filtered zip range is accessible)
$(LI $(BUGZILLA 14615): std.regex.replaceFirstInto throws exception when no match is found)
$(LI $(BUGZILLA 14966): Comparing two std.xml.Document result in infinite recursion)
$(LI $(BUGZILLA 15341): segfault with std.signals slots)
$(LI $(BUGZILLA 15658): isFile isn't a template)
$(LI $(BUGZILLA 15773): D's treatment of whitespace in character classes in free-form regexes is not the same as Perl's)
$(LI $(BUGZILLA 15791): Cannot get a stored nested struct object from Variant)
$(LI $(BUGZILLA 15823): opIndex doesn't work for const std.variant.Variant)
$(LI $(BUGZILLA 15827): std.variant.Variant can not be initialized with some struct)
$(LI $(BUGZILLA 15864): chmgen triggers exception in std.regex)
$(LI $(BUGZILLA 15865): std.file.copy$(LPAREN)from,to$(RPAREN) deletes the file if from and to specify the same file)
$(LI $(BUGZILLA 15872): [ndslice] indexing a slice with an array causes an error inside ndslice)
$(LI $(BUGZILLA 15874): getSymbolsByUDA fails if struct has no UDAs)
$(LI $(BUGZILLA 15884): Assigning char[] to std.json.JSONValue creates array, not string)
$(LI $(BUGZILLA 15885): float serialized to JSON loses precision)
$(LI $(BUGZILLA 15917): std.concurrency module destructor causes useless creation of new MessageBox)
$(LI $(BUGZILLA 15919): [ndslice] Undetected spell miss in selection.reshape$(LPAREN)$(RPAREN))
$(LI $(BUGZILLA 15920): std.traits.MemberFunctionsTuple gives a wrong result)
$(LI $(BUGZILLA 15960): SetUnion should filter duplicates)
$(LI $(BUGZILLA 15963): Hidden unresolved forward reference issue in std.uni)
$(LI $(BUGZILLA 15964): The template constraints for std.uni.sicmp are too permissive)
$(LI $(BUGZILLA 15973): nextPow2 and truncPow2 rely on processor specific behavior)
$(LI $(BUGZILLA 15980): std.traits.Identity is undocumented but public)
$(LI $(BUGZILLA 16010): [ndslice] byElement throw assert error)
$(LI $(BUGZILLA 16026): std.math.frexp!float$(LPAREN)$(RPAREN) wrong for very small subnormal values)
$(LI $(BUGZILLA 16036): std.net.isemail - isEmail reurns "valid: false" for any email with EmailStatusCode.none $(LPAREN)default$(RPAREN))
$(LI $(BUGZILLA 16046): ScopedAllocator does not set prev, causing segfaults)
$(LI $(BUGZILLA 16054): can break immutable with std.typecons.Rebindable)
$(LI $(BUGZILLA 16070): std.meta.{ApplyLeft,ApplyRight} fail with mixed type/value arguments)
$(LI $(BUGZILLA 16072): std.container.binaryheap should be extendable for arrays)
$(LI $(BUGZILLA 16090): popFront generates out-of-bounds array index on corrupted utf-8 strings)
$(LI $(BUGZILLA 16192): std.conv.toChars$(LPAREN)$(RPAREN) opSlice wrong for radix other than 10)
$(LI $(BUGZILLA 16219): std.experimental.allocator.makeArray does unnecessary allocations for ranges with length)
$(LI $(BUGZILLA 16238): std.string.lastIndexOf fails compilation with -de)
$(LI $(BUGZILLA 16241): std.xml mistakenly disallows "==" in comments but allows "--")
$(LI $(BUGZILLA 16331): std.container.array constructor shouldn't check result of emplacement)
$(LI $(BUGZILLA 16351): Nonstandard output library causes no-argument writeln$(LPAREN)$(RPAREN) to fail.)
$(LI $(BUGZILLA 16372): Broken links in documentation)
$(LI $(BUGZILLA 16383): Algebraic visit does not match handlers to const classes)
$(LI $(BUGZILLA 16385): std.range: undefined behaviour when skipping over 0xff in string.popFront)
$(LI $(BUGZILLA 16386): std.concurrency: destructors called twice on objects passed as Message)
$(LI $(BUGZILLA 16387): getSymbolsByUDA works with structs but fails with classes)
$(LI $(BUGZILLA 16413): multiSort doesn't work with @system comparison function)
$(LI $(BUGZILLA 16420): Incorrect example in std.getopt docs)
$(LI $(BUGZILLA 16501): packed ndslices does not compile)
$(LI $(BUGZILLA 16503): [ndslice] prevents fastmath LDC attribute)
$(LI $(BUGZILLA 16506): segfaults in std.experimental.allocator: FreeTree with GCAllocator or Mallocator)
$(LI $(BUGZILLA 16507): std.experimental.allocator: FreeTree clears too eagerly)
)
)
$(BUGSTITLE Phobos enhancements,

$(P
$(LI $(BUGZILLA 2104): std.regex: escape function for regular expressions)
$(LI $(BUGZILLA 7551): Regex parsing bug for right bracket in character class)
$(LI $(BUGZILLA 10777): std.algorithm.multiSort to return a std.range.SortedRange)
$(LI $(BUGZILLA 11229): std.string.toLower is slow)
$(LI $(BUGZILLA 12227): Allow matching multiple patterns in one go with std.regex)
$(LI $(BUGZILLA 12367): std.regex: Recognize $(LPAREN)?# ... $(RPAREN) comment syntax)
$(LI $(BUGZILLA 12379): Add toFile function which writes its first argument to a file)
$(LI $(BUGZILLA 13409): std.range.padLeft/Right)
$(LI $(BUGZILLA 13422): std.ascii has isAlphaNum but std.uni doesn't)
$(LI $(BUGZILLA 13796): A simple "array head const" struct for Phobos)
$(LI $(BUGZILLA 15229): BigInt$(LPAREN)Range of chars$(RPAREN) too)
$(LI $(BUGZILLA 15797): Add Option to Not Drop Matches in std.regex.splitter)
$(LI $(BUGZILLA 15800): std.conv.to!int does not work with ranges of any char type)
$(LI $(BUGZILLA 15803): std.file should support sub-second file time precision on POSIX)
$(LI $(BUGZILLA 15860): lockstep should support foreach_reverse)
$(LI $(BUGZILLA 15991): std.datetime.StopWatch is not @nogc)
$(LI $(BUGZILLA 15995): std.conv.text and friends can be made faster with std.array.appender)
$(LI $(BUGZILLA 16308): [ndslice] should always has save primitive)
$(LI $(BUGZILLA 16311): toHash for Slice is not defined)
$(LI $(BUGZILLA 16315): [] ?= operations does not work with packed slices [ndslice])
$(LI $(BUGZILLA 16319): std.experimental.allocator.make subtly wrong with nested classes)
$(LI $(BUGZILLA 16363): Cannot construct a random access range using frontTransversal)
$(LI $(BUGZILLA 16364): getUDAs and hasUDA do not give consistent results)
$(LI $(BUGZILLA 16443): std.getopt: segmentation fault with empty string option)
)
)
$(BUGSTITLE Druntime regressions,

$(P
$(LI $(BUGZILLA 1180): the GC failes to handle large allocation requests propperly)
$(LI $(BUGZILLA 16211): [REG 2.058] Cyclic dependencies broken again)
)
)
$(BUGSTITLE Druntime bugs,

$(P
$(LI $(BUGZILLA 6333): The 'capacity' function is not pure/nothrow/@safe.)
$(LI $(BUGZILLA 14601): pthread functions aren't marked @nogc)
$(LI $(BUGZILLA 15111): hashOf fails for structs that have an alias this to a dynamic array)
$(LI $(BUGZILLA 15838): Many Win32 API callback functions miss extern$(LPAREN)Windows$(RPAREN))
$(LI $(BUGZILLA 15958): Missing extern$(LPAREN)Windows$(RPAREN) of core.sys.windows functions)
$(LI $(BUGZILLA 15959): core.sys.windows modules should be modified for x64)
$(LI $(BUGZILLA 15976): explicite TLS initializes badly in DLLs if other threads exist)
$(LI $(BUGZILLA 15987): core.sys.windows.msacm remains pseudo definitions)
$(LI $(BUGZILLA 15997): Wrong constant value for ERROR_WINHTTP_CLIENT_AUTH_CERT_NEEDED in winhttp)
$(LI $(BUGZILLA 16007): Some Win32 API structs has wrong definitions)
$(LI $(BUGZILLA 16049): core.sys.windows structs have wrong sizes and aligns)
$(LI $(BUGZILLA 16594): module destructors called again if an exception got thrown earlier)
)
)
$(BUGSTITLE Druntime enhancements,

$(P
$(LI $(BUGZILLA 14117): core.atomic should be @safe)
)
)
$(BUGSTITLE dlang.org bugs,

$(P
$(LI $(BUGZILLA 15442): Eponymous template restrictions should be documented)
$(LI $(BUGZILLA 16004): Document changes to protection attributes)
$(LI $(BUGZILLA 16016): Remove std.concurrencybase from the docs)
$(LI $(BUGZILLA 16040): Remove Dconf announcement)
$(LI $(BUGZILLA 16114): [ddox] "Improve this page" links broken for package.d modules)
$(LI $(BUGZILLA 16167): chm-nav.json generation is broken)
$(LI $(BUGZILLA 16186): [Programming in D for C Programmers] Backticks should be escaped in explanation of raw string syntax)
$(LI $(BUGZILLA 16231): Language specification: rename std.regexp -> std.regex)
)
)
$(BUGSTITLE dlang.org enhancements,

$(P
$(LI $(BUGZILLA 16141): Organizations page unreachable)
$(LI $(BUGZILLA 16152): dpl-docs/ddox doesn't show documentation for eponymous template member)
$(LI $(BUGZILLA 16464): opCast doco is insufficient)
)
)
$(BUGSTITLE Installer bugs,

$(P
$(LI $(BUGZILLA 16349): better curl retry for install.sh script)
)
)

$(CHANGELOG_NAV_INJECT)

Macros:
        VER=2.072.0
        TITLE=Change Log: $(VER)
